const ResourceTypes={VertexBuffers:"VertexBuffers",IndexBuffer:"IndexBuffer",Uniforms:"Uniforms",Textures:"Textures",OffscreenTarget:"OffscreenTarget"},SchemaTypes={vec4:"vec4",vec3:"vec3",vec2:"vec2",int:"int",float:"float",mat4:"mat4",mat3:"mat3",mat2:"mat2",tex2D:"tex2D",texCube:"texCube"},GLTypes={Triangles:"Triangles",Lines:"Lines",Repeat:"Repeat",MirroredRepeat:"MirroredRepeat",ClampToEdge:"ClampToEdge",Nearest:"Nearest",Linear:"Linear",NearestMipmapNearest:"NearestMipmapNearest",LinearMipmapNearest:"LinearMipmapNearest",NearestMipmapLinear:"NearestMipmapLinear",LinearMipmapLinear:"LinearMipmapLinear",RGB:"RGB",RGBA:"RGBA",SRGB:"SRGB"},RendererConfig={contextAttributes:{},extensions:["OES_element_index_uint","WEBGL_depth_texture"]},isPowerOf2=e=>0==(e&e-1),mapValue=(e,t)=>Object.keys(e).reduce((r,a)=>({...r,[a]:t(e,a)}),{}),getNumComponents=e=>{const{vec2:t,vec3:r,vec4:a,float:n}=SchemaTypes;return{[t]:2,[r]:3,[a]:4,[n]:1}[e]},groupResources=e=>{const t=ResourceTypes;let[r,a,n,s]=[{},null,{},{}];for(let o=0;o<e.length;o++){const i=e[o],{type:u}=i;u===t.VertexBuffers?r={...r,...i.buffers}:u===t.IndexBuffer?a=i:u===t.Uniforms?n={...n,...i.state}:u===t.Textures&&(s={...s,...i.textures})}return[r,a,n,s]},isSafari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),getWebGLInstance=(e,t)=>e.getContext("webgl",t),getExtensions=(e,t)=>{const r={};return t.extensions.forEach(t=>{r[t]=e.getExtension(t)}),r},compileShader=(e,t,r)=>{const a=e.createShader(t);return e.shaderSource(a,r),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS)?a:(console.error("Error compiling shaders",e.getShaderInfoLog(a)),e.deleteShader(a),null)},initShaderProgram=(e,t,r,a)=>{const n=Object.keys(t).reduce((e,r)=>t[r]?e+`#define ${r} ${t[r]}\n`:"",""),s=compileShader(e,e.VERTEX_SHADER,n+r),o=compileShader(e,e.FRAGMENT_SHADER,n+a),i=e.createProgram();return e.attachShader(i,s),e.attachShader(i,o),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)?i:(console.error("Error initing program",e.getProgramInfoLog(i)),null)},initShaderRefs=(e,t,r,a,n)=>{const s=initShaderProgram(e,t,a,n),o=mapValue(r.buffers,(t,r)=>({type:t[r].type,location:e.getAttribLocation(s,r)})),i=mapValue({...r.uniforms,...r.textures},(t,r)=>({type:t[r].type,location:e.getUniformLocation(s,r)}));return{program:s,attributes:o,uniforms:i}},clear=(e,t)=>{const[r,a,n,s]=t;e.viewport(0,0,e.canvas.width,e.canvas.height),e.clearColor(r,a,n,s),e.clearDepth(1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),e.enable(e.DEPTH_TEST)},initVertexBuffers=(e,t)=>{const r={};return Object.keys(t).forEach(a=>{const n=e.createBuffer();r[a]=n,updateVertexBuffer(e,r[a],t[a])}),r},updateVertexBuffer=(e,t,r)=>{const a=r instanceof Float32Array?r:new Float32Array(r);e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,a,e.STATIC_DRAW)},destroyVertexBuffer=(e,t)=>{e.deleteBuffer(t)},initIndexBuffer=(e,t)=>{const{array:r}=t,a=e.createBuffer();return updateIndexBuffer(e,a,r),a},updateIndexBuffer=(e,t,r)=>{const a=r instanceof Uint32Array?r:new Uint32Array(r);e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,a,e.STATIC_DRAW)},destroyIndexBuffer=(e,t)=>{e.deleteBuffer(t)},compatSRGB=e=>{const{extensions:t}=e;return!isSafari&&t.EXT_SRGB?t.EXT_SRGB.SRGB_EXT:e.RGBA},compatSRGBA=e=>{const{extensions:t}=e;return!isSafari&&t.EXT_SRGB?t.EXT_SRGB.SRGB_ALPHA_EXT:e.RGBA},nativeTypeHOF=e=>t=>{return{[GLTypes.Repeat]:e.REPEAT,[GLTypes.MirroredRepeat]:e.MIRRORED_REPEAT,[GLTypes.ClampToEdge]:e.CLAMP_TO_EDGE,[GLTypes.Linear]:e.LINEAR,[GLTypes.Nearest]:e.NEAREST,[GLTypes.NearestMipmapNearest]:e.NEAREST_MIPMAP_NEAREST,[GLTypes.LinearMipmapNearest]:e.LINEAR_MIPMAP_NEAREST,[GLTypes.NearestMipmapLinear]:e.NEAREST_MIPMAP_LINEAR,[GLTypes.LinearMipmapLinear]:e.LINEAR_MIPMAP_LINEAR,[GLTypes.RGB]:e.RGB,[GLTypes.RGBA]:e.RGBA,[GLTypes.SRGB]:compatSRGB(e),[GLTypes.SRGBA]:compatSRGBA(e)}[t]},init2DTexture=(e,t)=>{const r=e.createTexture();return update2DTexture(e,r,t),r},initCubeTexture=(e,t)=>{const r=e.createTexture();return updateCubeTexture(e,r,t),r},initTextures=(e,t)=>{const r={};return Object.keys(t).forEach(a=>{const n=t[a];n.type=n.type||SchemaTypes.tex2D;const s=n.type===SchemaTypes.tex2D?init2DTexture(e,n):initCubeTexture(e,n);r[a]=s}),r},supportMipmap=e=>e&&isPowerOf2(e.width)&&isPowerOf2(e.height)&&"VIDEO"!==e.nodeName,update2DTexture=(e,t,r)=>{const a=nativeTypeHOF(e),{image:n,flip:s,space:o}=r;let{wrapS:i,wrapT:u,minFilter:c,magFilter:T}=r;if(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),n){s?e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0):e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1);const t=a(o||GLTypes.RGBA);e.texImage2D(e.TEXTURE_2D,0,t,t,e.UNSIGNED_BYTE,n),supportMipmap(n)&&e.generateMipmap(e.TEXTURE_2D),supportMipmap(n)||(i||(i=GLTypes.ClampToEdge),u||(u=GLTypes.ClampToEdge),c||(c=GLTypes.Linear))}return i&&e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,a(i)),u&&e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,a(u)),c&&e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,a(c)),T&&e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,a(T)),t},updateCubeTexture=(e,t,r)=>{const a=nativeTypeHOF(e),{images:n,level:s,flip:o,wrapS:i,wrapT:u,minFilter:c,magFilter:T,space:f}=r;if(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_CUBE_MAP,t),i&&e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,a(i)),u&&e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,a(u)),c&&e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,a(c)),T&&e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,a(T)),n){o?e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0):e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1);const t=[e.TEXTURE_CUBE_MAP_POSITIVE_X,e.TEXTURE_CUBE_MAP_NEGATIVE_X,e.TEXTURE_CUBE_MAP_POSITIVE_Y,e.TEXTURE_CUBE_MAP_NEGATIVE_Y,e.TEXTURE_CUBE_MAP_POSITIVE_Z,e.TEXTURE_CUBE_MAP_NEGATIVE_Z];let r=0;const i=a(f||GLTypes.RGBA);for(let a=0;a<t.length;a++)for(let o=0;o<=s;o++){const s=t[a];e.texImage2D(s,o,i,i,e.UNSIGNED_BYTE,n[r]),r++}}return t},destroyTexture=(e,t)=>{e.deleteTexture(t)},initColorOffscreen=(e,t)=>{const r=e.createFramebuffer(),a=e.createRenderbuffer(),n=e.createTexture(),{size:s}=t;e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,s,s,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.bindRenderbuffer(e.RENDERBUFFER,a),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,s,s),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,a);const o=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.FRAMEBUFFER_COMPLETE!==o&&console.error("Frame buffer object is incomplete: "+o.toString()),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),e.bindRenderbuffer(e.RENDERBUFFER,null),{fbo:r,rbo:a,colorTexture:n,depthTexture:null}},initDepthOffscreen=(e,t)=>{const{size:r}=t,a=e.createFramebuffer(),n=e.createTexture(),s=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r,r,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindTexture(e.TEXTURE_2D,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.DEPTH_COMPONENT,r,r,0,e.DEPTH_COMPONENT,e.UNSIGNED_SHORT,null),e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0),e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,s,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER);return o!==e.FRAMEBUFFER_COMPLETE&&console.error("framebuffer not complete",o.toString()),e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),{fbo:a,rbo:null,colorTexture:n,depthTexture:s}},initOffscreen=(e,t)=>t.depth?initDepthOffscreen(e,t):initColorOffscreen(e,t),padDefault=(e,t,r)=>void 0!==r?r:e.uniforms[t].default;let lastProgram=null;const draw=(e,t,r,a,n,s)=>{const{schema:o,shaderRefs:i}=t,{program:u}=i;lastProgram&&lastProgram===u||(e.useProgram(u),lastProgram=u),Object.keys(i.attributes).forEach(t=>{if(!o.buffers[t]||o.buffers[t].type===SchemaTypes.index||!r[t])return;const{location:a}=i.attributes[t],{n:n,type:s}=o.buffers[t],u=n||getNumComponents(s);e.bindBuffer(e.ARRAY_BUFFER,r[t]),e.vertexAttribPointer(a,u,e.FLOAT,!1,0,0),e.enableVertexAttribArray(a)});const{buffer:c,state:T}=a,{offset:f,count:E}=T;c&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,c);let m=-1;Object.keys(i.uniforms).forEach(t=>{const{type:r,location:a}=i.uniforms[t];let u;const c=r===SchemaTypes.tex2D||r===SchemaTypes.texCube;c||(u=padDefault(o,t,n[t])),(u||c)&&(void 0!==u||c)&&{[SchemaTypes.vec4]:()=>e.uniform4fv(a,u),[SchemaTypes.vec3]:()=>e.uniform3fv(a,u),[SchemaTypes.vec2]:()=>e.uniform2fv(a,u),[SchemaTypes.int]:()=>{u&&"number"!=typeof u&&"string"!=typeof u?e.uniform1iv(a,u):e.uniform1i(a,u)},[SchemaTypes.float]:()=>{u&&"number"!=typeof u&&"string"!=typeof u?e.uniform1fv(a,u):e.uniform1f(a,u)},[SchemaTypes.mat4]:()=>e.uniformMatrix4fv(a,!1,u),[SchemaTypes.mat3]:()=>e.uniformMatrix3fv(a,!1,u),[SchemaTypes.mat2]:()=>e.uniformMatrix2fv(a,!1,u),[SchemaTypes.tex2D]:()=>{m++;const r=s[t];r?(e.uniform1i(a,m),e.activeTexture(e.TEXTURE0+m),e.bindTexture(e.TEXTURE_2D,r)):console.warn(`Missing texture ${t} at unit ${m}`)},[SchemaTypes.texCube]:()=>{m++;const r=s[t];r?(e.uniform1i(a,m),e.activeTexture(e.TEXTURE0+m),e.bindTexture(e.TEXTURE_CUBE_MAP,r)):console.warn(`Missing texture ${t} at unit ${m}`)}}[r]()});const R=o.mode===GLTypes.Triangles?e.TRIANGLES:e.LINES;e.drawElements(R,E,e.UNSIGNED_INT,4*f)};class Shader{constructor(e,t){this.beam=e;const{buffers:r={},uniforms:a={},textures:n={},mode:s=GLTypes.Triangles}=t;this.schema={buffers:r,uniforms:a,textures:n,mode:s};const{vs:o,fs:i,defines:u={}}=t;this.shaderRefs=initShaderRefs(e.gl,u,this.schema,o,i)}set({vs:e,fs:t,defines:r}){}}const createResource=(e,t,r)=>{class a{constructor(){this.state=r,this.type=t}set(e,t){return this.state[e]=t,this}}return{[ResourceTypes.VertexBuffers]:()=>new class extends a{constructor(){super(),this.buffers=initVertexBuffers(e,r)}set(t,r){return this.state[t]=r,updateVertexBuffer(e,this.buffers[t],r),this}destroy(t){destroyVertexBuffer(e,this.buffers[t]),delete this.state[t]}},[ResourceTypes.IndexBuffer]:()=>new class extends a{constructor(){super();const{offset:t=0,count:a=r.array.length}=r;this.state.offset=t,this.state.count=a,this.buffer=initIndexBuffer(e,r)}set(t){const{offset:r=0,count:a=t.array.length}=t;return this.state.offset=r,this.state.count=a,updateIndexBuffer(e,this.buffer,t.array),this}destroy(){destroyIndexBuffer(e,this.buffer),delete this.state}},[ResourceTypes.Uniforms]:()=>new class extends a{},[ResourceTypes.Textures]:()=>new class extends a{constructor(){super(),this.textures=initTextures(e,r)}set(t,r){const{textures:a,state:n}=this,s=n[t];let o;if("Object"!==r.constructor.name){const e=r;o=e.state.depth?e.depthTexture:e.colorTexture}else if(s){const n={...r,flip:s.flip,space:s.space};o=s.image?update2DTexture(e,a[t],n):updateCubeTexture(e,a[t],n)}else o=r.image?init2DTexture(e,r):initCubeTexture(e,r);return a[t]=o,n[t]={...n[t],...r},this}destroy(t){destroyTexture(e,this.textures[t]),delete this.state[t]}},[ResourceTypes.OffscreenTarget]:()=>new class extends a{constructor(){super();const{size:t=2048}=this.state;this.state.size=t;const{fbo:a,rbo:n,colorTexture:s,depthTexture:o}=initOffscreen(e,r);this.fbo=a,this.rbo=n,this.colorTexture=s,this.depthTexture=o}}}[t]()};class Beam{constructor(e,t={}){this.gl=getWebGLInstance(e,t.contextAttributes),this.config={...RendererConfig,...t},this.gl.extensions=getExtensions(this.gl,this.config)}clear(e=[0,0,0,0]){return clear(this.gl,e),this}draw(e,...t){const r=groupResources(t);return draw(this.gl,e,...r),this}shader(e){return new Shader(this,e)}resource(e,t={}){return createResource(this.gl,e,t)}define({name:e,onBefore:t,onAfter:r}){this[e]=((e,a=(()=>{}))=>(t&&t(this.gl,e),a(e),r&&r(this.gl,e),this))}}const beforeWithColor=(e,t)=>{const{state:r,colorTexture:a,fbo:n,rbo:s}=t,{size:o}=r;e.viewport(0,0,o,o),e.bindFramebuffer(e.FRAMEBUFFER,n),e.bindRenderbuffer(e.RENDERBUFFER,s),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,o,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)},beforeWithDepth=(e,t)=>{const{state:r,fbo:a}=t,{size:n}=r;e.viewport(0,0,n,n),e.bindFramebuffer(e.FRAMEBUFFER,a),e.clear(e.DEPTH_BUFFER_BIT)},Offscreen2DCommand={name:"offscreen2D",onBefore(e,t){const{depth:r}=t.state;r?beforeWithDepth(e,t):beforeWithColor(e,t)},onAfter(e){e.bindFramebuffer(e.FRAMEBUFFER,null),e.viewport(0,0,e.canvas.clientWidth,e.canvas.clientHeight)}},conwayVS="\nattribute vec4 position;\nattribute vec2 texCoord;\n\nvarying highp vec2 vTexCoord;\n\nvoid main() {\n  gl_Position = position;\n  vTexCoord = texCoord;\n}\n",conwayFS="\nprecision highp float;\nuniform sampler2D state;\nvarying vec2 vTexCoord;\n\nconst float size = 1.0 / 2048.0;\nconst float decay = 0.95;\n\nvoid main() {\n  float total = 0.0;\n  total += texture2D(state, vTexCoord + vec2(-1.0, -1.0) * size).x > 0.5 ? 1.0 : 0.0;\n  total += texture2D(state, vTexCoord + vec2(0.0, -1.0) * size).x > 0.5 ? 1.0 : 0.0;\n  total += texture2D(state, vTexCoord + vec2(1.0, -1.0) * size).x > 0.5 ? 1.0 : 0.0;\n  total += texture2D(state, vTexCoord + vec2(-1.0, 0.0) * size).x > 0.5 ? 1.0 : 0.0;\n  total += texture2D(state, vTexCoord + vec2(1.0, 0.0) * size).x > 0.5 ? 1.0 : 0.0;\n  total += texture2D(state, vTexCoord + vec2(-1.0, 1.0) * size).x > 0.5 ? 1.0 : 0.0;\n  total += texture2D(state, vTexCoord + vec2(0.0, 1.0) * size).x > 0.5 ? 1.0 : 0.0;\n  total += texture2D(state, vTexCoord + vec2(1.0, 1.0) * size).x > 0.5 ? 1.0 : 0.0;\n\n  vec3 old = texture2D(state, vTexCoord).xyz;\n  gl_FragColor = vec4(0.0, old.yz * decay, 1.0);\n\n  if (old.x == 0.0) {\n    if (total == 3.0) {\n      gl_FragColor = vec4(1.0);\n    }\n  } else if (total == 2.0 || total == 3.0) {\n    gl_FragColor = vec4(1.0);\n  }\n}\n",{vec2:vec2,vec4:vec4,tex2D:tex2D}=SchemaTypes,ConwayLifeGame={vs:conwayVS,fs:conwayFS,buffers:{position:{type:vec4,n:3},texCoord:{type:vec2,n:2}},textures:{state:{type:tex2D}}},defaultVS="\nattribute vec4 position;\nattribute vec2 texCoord;\n\nvarying highp vec2 vTexCoord;\n\nvoid main() {\n  gl_Position = position;\n  vTexCoord = texCoord;\n}\n",defaultFS="\nprecision highp float;\nuniform sampler2D img;\n\nvarying highp vec2 vTexCoord;\n\nvoid main() {\n  vec4 texColor = texture2D(img, vTexCoord);\n  gl_FragColor = texColor;\n}\n",{vec2:vec2$1,vec4:vec4$1,float:float,tex2D:tex2D$1}=SchemaTypes,BasicImage={vs:defaultVS,fs:defaultFS,buffers:{position:{type:vec4$1,n:3},texCoord:{type:vec2$1}},textures:{img:{type:tex2D$1}}},push=(e,t)=>{e[e.length]=t},createRect=(e=[0,0,0],t=1,r=1)=>{const a=[-1,-1*t,0,1,-1*t,0,1,1*t,0,-1,1*t,0].map(e=>e*r),n=[];for(let t=0;t<a.length;t+=3)push(n,a[t]+e[0]),push(n,a[t+1]+e[1]),push(n,a[t+2]+e[2]);return{vertex:{position:n,normal:[0,0,1,0,0,1,0,0,1,0,0,1],texCoord:[0,0,1,0,1,1,0,1]},index:{array:[0,1,2,0,2,3]}}},loadImage=e=>new Promise(t=>{const r=new Image;r.onload=(()=>t(r)),r.src=e}),loadSVG=e=>new Promise(t=>{fetch(e).then(e=>e.text()).then(e=>{const r=new Blob([e],{type:"image/svg+xml"}),a=URL.createObjectURL(r),n=new Image;n.src=a,n.onload=(()=>t(n))})}),loadURL=e=>{return"svg"===e.split(".").pop()?loadSVG(e):loadImage(e)},loadImages=(...e)=>Promise.all(e.map(loadURL)),{VertexBuffers:VertexBuffers,IndexBuffer:IndexBuffer,Textures:Textures,OffscreenTarget:OffscreenTarget}=ResourceTypes,canvas=document.querySelector("canvas"),beam=new Beam(canvas);beam.define(Offscreen2DCommand);const conwayShader=beam.shader(ConwayLifeGame),imageShader=beam.shader(BasicImage),quad=createRect(),quadBuffers=[beam.resource(VertexBuffers,quad.vertex),beam.resource(IndexBuffer,quad.index)],conwayTexture=beam.resource(Textures),screenTexture=beam.resource(Textures),targetA=beam.resource(OffscreenTarget),targetB=beam.resource(OffscreenTarget),inputCanvas=document.createElement("canvas"),ctx=inputCanvas.getContext("2d"),size=2048;inputCanvas.width=2048,inputCanvas.height=2048;const initRandomInput=()=>{i%2!=0&&render(),ctx.clearRect(0,0,2048,2048),ctx.fillStyle="white";for(let e=0;e<5e4;e++)ctx.fillRect(2048*Math.random(),2048*Math.random(),1,1);conwayTexture.set("state",{image:inputCanvas}),initRender()},initImageInput=e=>{loadImages("./"+e).then(([e])=>{i%2!=0&&render();const t=Math.floor(.5*(2048-e.width)),r=Math.floor(.5*(2048-e.height));ctx.clearRect(0,0,2048,2048),ctx.drawImage(e,t,r),conwayTexture.set("state",{image:inputCanvas}),initRender()})};let timer,i=0;const initRender=()=>{cancelAnimationFrame(timer),conwayTexture.set("state",{magFilter:GLTypes.Nearest,minFilter:GLTypes.Nearest,flip:!0}),beam.clear(),beam.offscreen2D(targetA,()=>{beam.draw(conwayShader,...quadBuffers,conwayTexture)}),beam.resource(Textures).set("img",targetA),tick()},render=()=>{const e=i%2==0?targetA:targetB,t=i%2==0?targetB:targetA;beam.clear(),beam.offscreen2D(t,()=>{conwayTexture.set("state",e),beam.draw(conwayShader,...quadBuffers,conwayTexture)}),screenTexture.set("img",t),beam.draw(imageShader,...quadBuffers,screenTexture),i++},tick=()=>{render(),timer=requestAnimationFrame(tick)},$patternSelect=document.getElementById("pattern-select");$patternSelect.addEventListener("change",()=>{const e=$patternSelect.value;"random"===e?initRandomInput():initImageInput(e)}),initImageInput("oscillators.png");